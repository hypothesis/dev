#!/usr/bin/env python3

import argparse
import os
import re
import subprocess
from collections import defaultdict
from contextlib import contextmanager
from functools import lru_cache
from pathlib import Path


def print_verbose(verbose, message):
    if verbose:
        print(message)


@contextmanager
def working_directory(path):
    cwd = os.getcwd()
    try:
        os.chdir(path)
        yield
    finally:
        os.chdir(cwd)


class Project:
    PY_EXTENSION = re.compile('.py$')
    TEST_EXTENSION = re.compile('_test.py$')

    def __init__(self, root=None, match_tests=True):
        if root is None:
            root = os.getcwd()

        if not os.path.isdir(root):
            raise EnvironmentError(f"Cannot find project root: {root}")

        self.root = Path(os.path.abspath(root))

        self.all_files = self._get_changed_files()
        self.files = self._categorise(self.all_files)
        if match_tests:
            self._match_tests(self.files)

    def _get_changed_files(self):
        with working_directory(self.root):
            files = (
                subprocess.run(
                    ["git", "diff", "origin/master", "--name-only"],
                    check=True,
                    stdout=subprocess.PIPE,
                )
                    .stdout.decode("utf8")
                    .split()
            )

        return [os.path.join(self.root, f) for f in files if f.endswith(".py")]

    def _categorise(self, files):
        """Categories the files by what kind of thing they are."""
        paths = {
            'func_test': self.root / 'tests/functional',
            'unit_test': self.root / 'tests' / self._unit_prefix(),
            'source': self.root
        }

        results = defaultdict(set)
        for file in files:
            for path_type, prefix in paths.items():
                if file.startswith(str(prefix)):
                    results[path_type].add(file)
                    break

        return results

    def _match_tests(self, files):
        """Try and find tests that match files and vice versa."""

        for file in files['source']:
            test = self._test_for_file(file)
            if os.path.exists(test):
                self.all_files.append(str(test))
                files['unit_test'].add(str(test))

        for file in files['unit_test']:
            source = self._file_for_test(file)
            if os.path.exists(source):
                self.all_files.append(str(source))
                files['source'].add(str(source))

    def _file_for_test(self, name):
        unit_prefix = self._unit_prefix()

        if unit_prefix == 'unit':
            bare_name = os.path.relpath(name, self.root / 'tests/unit')
        else:
            bare_name = os.path.relpath(name, self.root / 'tests')

        bare_name = self.TEST_EXTENSION.sub('.py', bare_name)

        path = self.root / 'src' / bare_name

        if not os.path.exists(path):
            path = self.root / bare_name

        return path

    def _test_for_file(self, name):
        bare_name = os.path.relpath(name, self.root)
        if bare_name.startswith('src/'):
            bare_name = bare_name[4:]

        bare_name = self.PY_EXTENSION.sub('_test.py', bare_name)

        unit_prefix = self._unit_prefix()
        if unit_prefix == 'unit':
            return self.root / 'tests/unit' / bare_name

        return self.root / 'tests' / bare_name

    @lru_cache(1)
    def _unit_prefix(self):
        path = self.root / 'tests/unit'
        if os.path.isdir(path):
            return 'unit'

        # Looks like a non-standard one, time to guess
        options = set(os.listdir(self.root / 'tests'))
        options -= {'functional', 'common', '__pycache__'}
        options = [os.path.join(self.root, 'tests', option) for option in options]
        options = [option for option in options if os.path.isdir(option) and not option.startswith('.')]

        if len(options) == 1:
            return os.path.basename(options[0])

        raise EnvironmentError(f'Cannot determine unit test dir. Options are: {options}')


class Run:
    def __init__(self, tox, verbose):
        self._tox = tox
        self._verbose = verbose

    def __call__(self, env, cmd, files, options=""):
        files = " ".join(files)

        cmd_fmt = ".tox/{env}/bin/{cmd} {args}"
        tox_fmt = "tox -qqe {env} --run-command '{cmd} {args}'"

        if self._tox:
            fmt = tox_fmt
        else:
            fmt = cmd_fmt

        if options:
            args = [options, files]
        else:
            args = [files]

        cmd = fmt.format(env=env, cmd=cmd, args=" ".join(args))

        if self._verbose:
            print(cmd)

        subprocess.run(cmd, shell=True, check=True)


def main():
    parser = argparse.ArgumentParser(
        description="Format, lint and test only the files that have changed on this branch.",
        epilog="By default commands are run directly rather than with tox. "
        "This is faster but it can fail because it doesn't allow tox to "
        "create virtualenvs and install and update dependencies. If you run "
        "into a problem try running `%(prog)s -t` once to run the commands in "
        "tox and see if that fixes it, then go back to running `%(prog)s` "
        "without -t.",
    )
    parser.add_argument(
        "-t", "--tox",
        action="store_true", help="Run commands in tox instead of directly",
    )
    parser.add_argument(
        "--no-lint",
        action="store_true", help="Disable linting"
    )
    parser.add_argument(
        "--no-coverage",
        action="store_true", help="Disable coverage"
    )
    parser.add_argument(
        "--no-match",
        action="store_true", help="Don't try and match tests to source files"
    )
    parser.add_argument(
        "-v",  "--verbose",
        action="store_true", help="Verbose output"
    )

    args = parser.parse_args()

    project = Project(match_tests=not args.no_match)

    src_files = project.files.get('source')
    test_files = project.files.get('unit_test', set())
    functest_files = project.files.get('func_test', set())
    all_test_files = test_files | functest_files

    if project.all_files:
        run = Run(args.tox, args.verbose)

        run("format", "black", project.all_files)

        if not args.no_lint:
            if project:
                print_verbose(args.verbose, "Linting...")
                run("lint", "pylint", src_files)
                run("lint", "pycodestyle", src_files)
                run("lint", "pydocstyle", src_files)

            if all_test_files:
                print_verbose(args.verbose, "Linting tests...")
                run("lint", "pylint", all_test_files, "--rcfile=tests/.pylintrc")

        if test_files:
            print_verbose(args.verbose, "Run tests...")
            run("tests", "coverage run -m pytest", test_files, "-v")

            if not args.no_coverage:
                run("coverage", "coverage combine", [])
                run(
                    "coverage", "coverage report", [],
                    '--fail-under=0 --no-skip-covered --include '+','.join(project.all_files)
                )

        if functest_files:
            print_verbose(args.verbose, "Run functional tests...")
            run("functests", "pytest", functest_files)

        print_verbose(args.verbose, "Done")


if __name__ == "__main__":
    main()
